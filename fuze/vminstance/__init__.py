#!/usr/bin/python
from pwn import *
from multiprocessing import Process
import subprocess
import os
import socket
import qemuconfig
context.update(arch = 'amd64')
context.log_level = 'warning'
class vmInstance(object):
    def __init__(self, qemu_config_file, qemu_script=None
            , ssh_host='127.0.0.1'
            , log_filename='vm_log.txt'
            , gdb_deamon_port=2323
            , two_cpus=True
            , start_grace_time=10
            , enable_vmx=False
            , enable_kvm=True
            , enable_trace=False
            , trace_boot=False
            , trace_event="/tmp/events"
            , trace_output="trace"
            , use_disk_snapshot=True
            ):
        self._ssh_host = ssh_host
        self.qemu_config = qemuconfig.qemuConfig(qemu_config_file)
        self._qemu_process =None
        self.__FNULL = open(os.devnull, 'w')
        self._ssh_port = self.qemu_config.ssh_port
        self._ssh_keyfile = self.qemu_config.ssh_keyfile
        self.s = None
        self._gdb_deamon = None
        self._socat_gdb_pid = None
        self._gdb_pid = None
        s1, s2 = socket.socketpair()
        self.__read_qemu = s1
        self.__write_qemu = s2
        s1, s2 = socket.socketpair()
        self.__read_socat = s1
        self.__write_socat = s2
        cmd = ['rm', '/home/ww9210/.ssh/known_hosts']
        subprocess.call(cmd)
        self.log_filename = log_filename
        self._gdb_deamon_port = gdb_deamon_port
        self._two_cpus = two_cpus
        self.start_grace_time = start_grace_time
        self._enable_vmx = enable_vmx
        self._enable_kvm = enable_kvm
        self._enable_trace = enable_trace
        self._trace_event = trace_event
        self._trace_output = trace_output
        self._trace_boot = trace_boot
        self._use_disk_snapshot = use_disk_snapshot
        #self._qemu_s1 = remote.fromsocket(s1)
        #self._qemu_s2 = remote.fromsocket(s2)

        return

    def start_vm(self):
        assert self.qemu_config != None
        logfile = open(self.log_filename,'w')
        cmd = []
        cmd.append(self.qemu_config.qemu_path)
        cmd.append('-kernel')
        cmd.append(self.qemu_config.kernel_path)
        cmd.append('-append')
        cmd.append(self.qemu_config.append)
        cmd.append('-hda')
        cmd.append(self.qemu_config.hda)
        cmd.append('-net')
        cmd.append('user,hostfwd=tcp::'+str(self.qemu_config.ssh_port)+'-:22')
        cmd.append('-net')
        cmd.append('nic')
        if self._use_disk_snapshot:
            cmd.append('-snapshot')  # disk snapshot
        if self._enable_kvm:
            cmd.append('-enable-kvm')
        if self._enable_vmx:
            cmd.append('-cpu')
            cmd.append('kvm64,+vmx')
        if self._enable_trace:
            if self._trace_boot:
                cmd.append('-trace')
                cmd.append('events=' + self._trace_event \
                        + ',file=' + self._trace_output)
            else:
                cmd.append('-trace')
                cmd.append('file='+self._trace_output)
        cmd.append('-nographic')
        cmd.append('-m')
        cmd.append(self.qemu_config.ram_size)
        cmd.append('-smp')
        if self._two_cpus:
            cmd.append('2')
        else:
            cmd.append('1')
        cmd.append('-monitor')
        cmd.append('tcp::' + str(self.qemu_config.monitor_port)\
                + ',server,nowait,nodelay,reconnect=-1')
        cmd.append('-gdb')
        cmd.append('tcp::' + str(self.qemu_config.gdb_port))
        cmd.append('-pidfile')
        cmd.append('vm.pid')
        #subprocess.call(cmd, stdout=self.__FNULL, stderr=subprocess.STDOUT)
        #subprocess.call(cmd, stdout=logfile, stderr=subprocess.STDOUT)
        subprocess.call(cmd, stdin = self.__write_qemu, stdout=logfile, stderr=logfile)


    def run_qemu(self):
        self._qemu_process = Process(target=self.start_vm)
        print self._qemu_process
        self._qemu_process.start()
        sleep(1) #grace period
        
    def test_vm(self):
        #class pwnlib.tubes.ssh.ssh(user, host, port=22, password=None, key=None, keyfile=None, proxy_command=None, proxy_sock=None, level=None, cache=True, ssh_agent=False, *a, **kw)
        s = pwnlib.tubes.ssh.ssh(user = 'root'\
                , host = self._ssh_host\
                , port = self._ssh_port\
                , keyfile = self._ssh_keyfile\
                , cache = False\
                )
        s.close()
        return


    def run(self, test_connection=True):
        self.run_qemu()
        #print('[..] Connecting to socat deamon of qemu-system, starting VM...')
        print(' booting...wait for up to '+str(self.start_grace_time)+' seconds...')
        if self.start_grace_time < 30:
            sleep(self.start_grace_time)
        else:
            while True:
                cont = file(self.log_filename,'r').read()
                if 'syzkaller login:' in cont:
                    break
                else:
                    sleep(2)
        if test_connection:
            print(' testing if the connection is built up...')
            self.test_vm()
            self.test_vm()
            print('[+] successfully starting the vm')
        return

    def connect(self, name='root'):
        self.s = pwnlib.tubes.ssh.ssh(user = name\
                , host = self._ssh_host\
                , port = self._ssh_port\
                , keyfile = self._ssh_keyfile\
                , cache = False\
                )
        return self.s

    def ssh_interactive(self): 
        if self.s != None:
            self.s.interactive()

    def start_gdb_deamon(self):
        cmd = 'socat TCP-LISTEN:' + str(self._gdb_deamon_port) + ',bind=127.0.0.1 EXEC:"gdb"'
        cmd = cmd.split()
        subprocess.call(cmd, stdin = self.__write_socat, stdout = self.__FNULL, stderr = self.__FNULL)
        #subprocess.call(cmd)

    def run_gdb_deamon(self):
        #self._qemu_process = Process(target=self.start_vm)
        #print self._qemu_process
        #self._qemu_process.start()
        #sleep(1) #grace period
        self._gdb_deamon = Process(target=self.start_gdb_deamon)
        self._gdb_deamon.start()
        sleep(1) #grace period
        pid = self._gdb_deamon.pid
        self._socat_gdb_pid = pwnlib.util.proc.children(pid)[0]
        print 'self._socat_gdb_pid',self._socat_gdb_pid
        
    def interrupt(self):
        self.interrupt_vm()

    def interrupt_vm(self):
        self._gdb_pid = pwnlib.util.proc.children(self._socat_gdb_pid)
        assert len(self._gdb_pid) == 1
        cmd = ['kill','-2',str(self._gdb_pid[0])]
        subprocess.call(cmd)

    def save_vm_snapshot(self):
        '''
        we choose to implement the function in statebroker
        '''
        print '[-]implemented in statebroker'
        pass

    def shutdown(self):
        print '[+] killing gdb...'
        if self._socat_gdb_pid != None:
            try:
                self._gdb_pid = pwnlib.util.proc.children(self._socat_gdb_pid)
                if len(self._gdb_pid)>0:
                    for _ in self._gdb_pid:
                        print 'kill',_
                        cmd = ['kill',str(_)]
                        subprocess.check_call(cmd)
            except:
                print 'fail to try to kill gdb instance'
            print '[+] killing gdb deamon'
            cmd = ['kill' , '-9' , str(self._socat_gdb_pid)]
            try:
                subprocess.check_call(cmd)
            except subprocess.CalledProcessError:
                pass


        print'[+] shutting down the vm'
        #from IPython import embed; embed()
        if self.s != None:
            self.s.close()

        if self._qemu_process!=None:
            print self._qemu_process.terminate()
            self._qemu_process.join()
        if self._gdb_deamon!=None:
            print self._gdb_deamon.terminate()
            self._gdb_deamon.join()

        if self._qemu_process!=None:
            qemu_pid = file('vm.pid').read().strip('\n').strip()
            print '[+] killing qemu emulator', qemu_pid
            cmd = ['kill',qemu_pid]
            subprocess.check_call(cmd)
        return

    def __del__(self):
        self.shutdown()



#from .vminstancekasan import vmInstanceKASan
